{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CSSE4011 Documentation This site contains links to guides used in the CSSE4011 stages and project. See the links on the left side menu.","title":"Home"},{"location":"#csse4011-documentation","text":"This site contains links to guides used in the CSSE4011 stages and project. See the links on the left side menu.","title":"CSSE4011 Documentation"},{"location":"getting_started/","text":"CSIRO/CSSE4011 open repository setup guide Hardware JLink Debugger/Programmer e.g. JLink EDU Mini nrf52840 particle argon/xenon other boards may be supported, i.e nrf52840dk, boards that are supported are listed in ei_freertos/core_csiro/platform Software Installation: The repo may be setup for Linux, OSX, or WSL, this guide will be using Linux. It is not recommended to use a virtual machine due to extended compilation times. VScode https://code.visualstudio.com/Download $ cd ~/Downloads $ sudo dpkg -i code_1.26.0-1534177765_amd64.deb git $ sudo apt install git Python 3 should be installed by default on ubuntu make sure python3 install Python headers and static libraries $ sudo apt-get install python3-dev install pip3 $ sudo apt install python3-pip dialout group add user to dialout group to acces /dev/tty devices $ sudo gpasswd --add ${USER} dialout reset machine gcc-arm-none-eabi For Debian try: $ sudo apt-get install gcc-arm-none-eabi For Ubuntu try: $ sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa $ sudo apt-get update $ sudo apt-get install gcc-arm-embedded Installing Segger JLink - download from https://www.segger.com/downloads/jlink/ - J-Link Software and Documentation pack for Linux, DEB installer, 64-bit $ sudo dpkg -i ~/Downloads/jlink_5.2.7_x86_64.deb Repository Setup Generate SSH Key $ ssh-keygen -t rsa -C \"example@example@uqconnect.edu.au\" $ ssh-add then copy the key from id_rsa.pub to your github account Set up environment variables add the following lines to ~/.bashrc export PATH= ei-freertos-path>/tools:$PATH export PYTHONPATH= ei-freertos-path>/pyclasses:$PYTHONPATH $ source ~/.bashrc Setup the Repository $ git clone https://github.com/uqembeddedsys/ei-freertos.git $ ./repo_setup.sh Compile and flash an app: compiling the app low_power: $ cd apps/low_power $ make TARGET=argon debug -j flashing an app connect your jlink EDU mini verifying JLink verify it is plugged in correctly and recognises the device $ JLinkExe connect S Enter If a Target device selection comes up, select nrf52840_xxAA, by nordic semiconductors, Cortex-M4 on subsequent connects it will be the default device flashing the app $ make TARGET=argon flashdbg -j blue LED should start blinking tips: $ make TARGET=argon help - generates help message $ make TARGET=argon jlinksn - get serial numbers of devices connected - useful for multiple devices connected $ make TARGET=argon JLINK= serial number - needed when multiple devices connected to computer or it will give you error, alternatively just take one out","title":"Getting Started"},{"location":"getting_started/#csirocsse4011-open-repository-setup-guide","text":"","title":"CSIRO/CSSE4011 open repository setup guide"},{"location":"getting_started/#hardware","text":"JLink Debugger/Programmer e.g. JLink EDU Mini nrf52840 particle argon/xenon other boards may be supported, i.e nrf52840dk, boards that are supported are listed in ei_freertos/core_csiro/platform","title":"Hardware"},{"location":"getting_started/#software-installation","text":"The repo may be setup for Linux, OSX, or WSL, this guide will be using Linux. It is not recommended to use a virtual machine due to extended compilation times. VScode https://code.visualstudio.com/Download $ cd ~/Downloads $ sudo dpkg -i code_1.26.0-1534177765_amd64.deb git $ sudo apt install git Python 3 should be installed by default on ubuntu make sure python3 install Python headers and static libraries $ sudo apt-get install python3-dev install pip3 $ sudo apt install python3-pip dialout group add user to dialout group to acces /dev/tty devices $ sudo gpasswd --add ${USER} dialout reset machine","title":"Software Installation:"},{"location":"getting_started/#gcc-arm-none-eabi","text":"For Debian try: $ sudo apt-get install gcc-arm-none-eabi For Ubuntu try: $ sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa $ sudo apt-get update $ sudo apt-get install gcc-arm-embedded","title":"gcc-arm-none-eabi"},{"location":"getting_started/#installing-segger-jlink","text":"- download from https://www.segger.com/downloads/jlink/ - J-Link Software and Documentation pack for Linux, DEB installer, 64-bit $ sudo dpkg -i ~/Downloads/jlink_5.2.7_x86_64.deb","title":"Installing Segger JLink"},{"location":"getting_started/#repository-setup","text":"","title":"Repository Setup"},{"location":"getting_started/#generate-ssh-key","text":"$ ssh-keygen -t rsa -C \"example@example@uqconnect.edu.au\" $ ssh-add then copy the key from id_rsa.pub to your github account","title":"Generate SSH Key"},{"location":"getting_started/#set-up-environment-variables","text":"add the following lines to ~/.bashrc export PATH= ei-freertos-path>/tools:$PATH export PYTHONPATH= ei-freertos-path>/pyclasses:$PYTHONPATH $ source ~/.bashrc","title":"Set up environment variables"},{"location":"getting_started/#setup-the-repository","text":"$ git clone https://github.com/uqembeddedsys/ei-freertos.git $ ./repo_setup.sh","title":"Setup the Repository"},{"location":"getting_started/#compile-and-flash-an-app","text":"","title":"Compile and flash an app:"},{"location":"getting_started/#compiling-the-app-low_power","text":"$ cd apps/low_power $ make TARGET=argon debug -j","title":"compiling the app low_power:"},{"location":"getting_started/#flashing-an-app","text":"connect your jlink EDU mini","title":"flashing an app"},{"location":"getting_started/#verifying-jlink","text":"verify it is plugged in correctly and recognises the device $ JLinkExe connect S Enter If a Target device selection comes up, select nrf52840_xxAA, by nordic semiconductors, Cortex-M4 on subsequent connects it will be the default device","title":"verifying JLink"},{"location":"getting_started/#flashing-the-app","text":"$ make TARGET=argon flashdbg -j blue LED should start blinking","title":"flashing the app"},{"location":"getting_started/#tips","text":"$ make TARGET=argon help - generates help message $ make TARGET=argon jlinksn - get serial numbers of devices connected - useful for multiple devices connected $ make TARGET=argon JLINK= serial number - needed when multiple devices connected to computer or it will give you error, alternatively just take one out","title":"tips:"},{"location":"mpy/","text":"Setting up MicroPython This tutorial covers how to install MicroPython on the B-L475E-IOT01A board. It also provides instructions on how to flash the board too, along with key files on an Ubuntu machine. Step 0. Install the necessary libraries The assumption this guide makes is that the arm-gcc-tool chain, stlink-tools, and Python3 are already installed. The other libraries that need to be installed are as followed as they handle the additional dependencies of MicroPython. sudo apt-get install libffi-dev sudo apt-get install pkg-config Step 1. Building MicroPython Repository Clone repository as usual. git clone https://github.com/micropython/micropython.git This is then followed by building mpy-cross folder. This allows the Python code to be cross-compiled into a .mpy file. Run this in the root of the repository. make -C mpy-cross Step 2. Building the STM32 MicroPython Port Once Step 1 has been completed, you should be ready to build the STM32 port of MicroPython. Go to the STM32 port folder located in ports/stm32 . # Assuming root directory cd ports/stm32 We then build the submodules that the STM32 library requires. make submodules We then build MicroPython to be compatible with our board. make BOARD=B_L475E_IOT01A Finally we flash the board using ST-LINK. This would update firmware. make BOARD=B_L475E_IOT01A deploy-stlink Step 3. Testing the connection To test/verify if the board has been flashed, connect to the board serially. This can be done with various software such as PuTTY; all that is needed is a baud rate of 115200. /bin/screen /dev/ttyACM0 115200 Pressing enter or CTRL-C should bring out the familiar command line interface of Python. You should then be able to run typical Python code normally. Step 4. Flashing your first application Flashing the board is simply a matter of using the pyboard.py file located in the tools folder. Go to the tools folder and create a main.py file. Using this code snippet below. # Machine is a MicroPython library. from machine import Pin import time # Get PB14 and treat it as a GPIO Output pin led_pin = Pin('PB14', Pin.OUT) value = 1 # Toggle the pin every one second while 1: led_pin.value(value) if value == 1: value = 0 else: value = 1 # Somewhat similar to HAL_Delay() time.sleep(1) Flashing the board is a matter of calling the bash commands below inside the tools folder. # Think of it as running the cp command as with most Linux systems. You are copying the main.py file and placing it inside the board with the same name. Device name is whatever appears on your machine. python3 pyboard.py --device /dev/ttyACM0 cp main.py :main.py Assuming everything follows, you should have a flashing LED that toggles every second. Notes Making development easier. Symlinks and env variables Typing python3 pyboard.py is a bit cumbersome. We can make this easier by creating a symlink. In the tools folder, run the following. sudo ln -s tools/pyboard.py /usr/bin/pyboard The following command should then run. pyboard.py --device /dev/ttyACM0 ls Of course, naming the device is a bit tiring. If you interact with only one board, then we can set the appropiate environment variable. # Assumes our board is located here. export PYBOARD_DEVICE=/dev/ttyACM0 Location and content of onboard files You won't be able to see the contents inside the MCU using a typical File Explorer. Copying and pasting code like that would most likely not work. The pyboard.py has commands that allows you to see what is stored there. python3 pyboard.py --device /dev/ttyACM0 ls Similarly we can see the content of what the main.py is using cat python3 pyboard.py --device /dev/ttyACM0 cat main.py","title":"MicroPython"},{"location":"mpy/#setting-up-micropython","text":"This tutorial covers how to install MicroPython on the B-L475E-IOT01A board. It also provides instructions on how to flash the board too, along with key files on an Ubuntu machine.","title":"Setting up MicroPython"},{"location":"mpy/#step-0-install-the-necessary-libraries","text":"The assumption this guide makes is that the arm-gcc-tool chain, stlink-tools, and Python3 are already installed. The other libraries that need to be installed are as followed as they handle the additional dependencies of MicroPython. sudo apt-get install libffi-dev sudo apt-get install pkg-config","title":"Step 0. Install the necessary libraries"},{"location":"mpy/#step-1-building-micropython-repository","text":"Clone repository as usual. git clone https://github.com/micropython/micropython.git This is then followed by building mpy-cross folder. This allows the Python code to be cross-compiled into a .mpy file. Run this in the root of the repository. make -C mpy-cross","title":"Step 1. Building MicroPython Repository"},{"location":"mpy/#step-2-building-the-stm32-micropython-port","text":"Once Step 1 has been completed, you should be ready to build the STM32 port of MicroPython. Go to the STM32 port folder located in ports/stm32 . # Assuming root directory cd ports/stm32 We then build the submodules that the STM32 library requires. make submodules We then build MicroPython to be compatible with our board. make BOARD=B_L475E_IOT01A Finally we flash the board using ST-LINK. This would update firmware. make BOARD=B_L475E_IOT01A deploy-stlink","title":"Step 2. Building the STM32 MicroPython Port"},{"location":"mpy/#step-3-testing-the-connection","text":"To test/verify if the board has been flashed, connect to the board serially. This can be done with various software such as PuTTY; all that is needed is a baud rate of 115200. /bin/screen /dev/ttyACM0 115200 Pressing enter or CTRL-C should bring out the familiar command line interface of Python. You should then be able to run typical Python code normally.","title":"Step 3. Testing the connection"},{"location":"mpy/#step-4-flashing-your-first-application","text":"Flashing the board is simply a matter of using the pyboard.py file located in the tools folder. Go to the tools folder and create a main.py file. Using this code snippet below. # Machine is a MicroPython library. from machine import Pin import time # Get PB14 and treat it as a GPIO Output pin led_pin = Pin('PB14', Pin.OUT) value = 1 # Toggle the pin every one second while 1: led_pin.value(value) if value == 1: value = 0 else: value = 1 # Somewhat similar to HAL_Delay() time.sleep(1) Flashing the board is a matter of calling the bash commands below inside the tools folder. # Think of it as running the cp command as with most Linux systems. You are copying the main.py file and placing it inside the board with the same name. Device name is whatever appears on your machine. python3 pyboard.py --device /dev/ttyACM0 cp main.py :main.py Assuming everything follows, you should have a flashing LED that toggles every second.","title":"Step 4. Flashing your first application"},{"location":"mpy/#notes","text":"","title":"Notes"},{"location":"mpy/#making-development-easier-symlinks-and-env-variables","text":"Typing python3 pyboard.py is a bit cumbersome. We can make this easier by creating a symlink. In the tools folder, run the following. sudo ln -s tools/pyboard.py /usr/bin/pyboard The following command should then run. pyboard.py --device /dev/ttyACM0 ls Of course, naming the device is a bit tiring. If you interact with only one board, then we can set the appropiate environment variable. # Assumes our board is located here. export PYBOARD_DEVICE=/dev/ttyACM0","title":"Making development easier. Symlinks and env variables"},{"location":"mpy/#location-and-content-of-onboard-files","text":"You won't be able to see the contents inside the MCU using a typical File Explorer. Copying and pasting code like that would most likely not work. The pyboard.py has commands that allows you to see what is stored there. python3 pyboard.py --device /dev/ttyACM0 ls Similarly we can see the content of what the main.py is using cat python3 pyboard.py --device /dev/ttyACM0 cat main.py","title":"Location and content of onboard files"},{"location":"tutorials/","text":"This page maintains any ongoing tutorials for using ei-freertos, check back here from time to time for updates. Tutorial 1 - Setting up the Repository with John Scolaro This tutorial covers how to set up the repository, as well as build and flash an application","title":"Tutorials"},{"location":"tutorials/#tutorial-1-setting-up-the-repository-with-john-scolaro","text":"This tutorial covers how to set up the repository, as well as build and flash an application","title":"Tutorial 1 - Setting up the Repository with John Scolaro"}]}